${
    using System.Text;

    Template(Settings settings)
    {
        settings
            .IncludeCurrentProject();
    }

    bool IsPropertyIncluded(Property p)
    {
        return !p.Attributes.Any(a => a.Name.Equals("JsonIgnore"));
    }

    // Recursively generate import statements. Modify at `type.isDefined` to import types other than types within the solution.
    void GenerateImportsForType(Typewriter.CodeModel.Type type, StringBuilder imports, HashSet<string> importMap)
    {
        if(type.TypeArguments.Any())
        {
            foreach(var subType in type.TypeArguments)
            {
                GenerateImportsForType(subType, imports, importMap);
            }
        }
        else if(type.IsDefined && !importMap.Contains(type.Name))
        {
            imports.AppendLine($"import {{ {type.Name} }} from './{type.Name}';");
            importMap.Add(type.Name);
        }
    }

    string ClassExtends(Class c)
    {
      return c.BaseClass == null ? string.Empty : $" extends {c.BaseClass.Name}";
    }

    string ClassConstructor(Class c)
    {
      return c.BaseClass == null ? "Object.assign(this, init);" : "super(init);";
    }

    // Generates imports only for properties
    string FormulateClassImports(Class currentClass)
    {
        HashSet<string> importMap = new HashSet<string> { currentClass.Name };
        StringBuilder imports = new StringBuilder();
        foreach(var prop in currentClass.Properties)
        {
            GenerateImportsForType(prop.Type, imports, importMap);
        }

        if(currentClass.BaseClass != null)
        {
          Type type = currentClass.BaseClass;
          if(!importMap.Contains(type.Name))
          {
            imports.AppendLine($"import {{ {type.Name} }} from './{type.Name}';");
          }
        }

        if(imports.Length > 0 && !string.IsNullOrWhiteSpace(currentClass.DocComment?.ToString()))
        {
          imports.Append(Environment.NewLine);
        }

        return imports.ToString();
    }

    // Generates imports for properties and methods on interfaces.
    string FormulateInterfaceImports(Interface currentInterface)
    {
        HashSet<string> importMap = new HashSet<string> { currentInterface.Name };
        StringBuilder imports = new StringBuilder();
        foreach(var prop in currentInterface.Properties)
        {
            GenerateImportsForType(prop.Type, imports, importMap);
        }

        foreach(var method in currentInterface.Methods)
        {
            GenerateImportsForType(method.Type, imports, importMap);
            foreach(var p in method.Parameters)
            {
                GenerateImportsForType(p.Type, imports, importMap);
            }
        }

        if(imports.Length > 0 && !string.IsNullOrWhiteSpace(currentInterface.DocComment?.ToString()))
        {
          imports.Append(Environment.NewLine);
        }

        return imports.ToString();
    }

    string DocComments(Class c)
    {
      var comment = c?.DocComment?.ToString() ?? "";
      return string.IsNullOrWhiteSpace(comment) ? "" : $"/** {comment} */";
    }

    string DocComments(Interface i)
    {
      var comment = i?.DocComment?.ToString() ?? "";
      return string.IsNullOrWhiteSpace(comment) ? "" : $"/** {comment} */";
    }

    string DocComments(Enum e)
    {
      var comment = e?.DocComment?.ToString() ?? "";
      return string.IsNullOrWhiteSpace(comment) ? "" : $"/** {comment} */";
    }

    string DocComments(EnumValue e)
    {
      var comment = e?.DocComment?.ToString() ?? "";
      return string.IsNullOrWhiteSpace(comment) ? "" : $"\r\n    /** {comment} */";
    }

    string DocComments(Property p)
    {
      var comment = p?.DocComment?.ToString() ?? "";
      return string.IsNullOrWhiteSpace(comment) ? "" : $"\r\n    /** {comment} */";
    }

    string DocComments(Method m)
    {
      var comment = m?.DocComment?.ToString() ?? "";
      return string.IsNullOrWhiteSpace(comment) ? "" : $"\r\n    /** {comment} */";
    }
}$Classes([TypeScriptModel])[// AutoGenerated File

$FormulateClassImports$DocComments
export class $Name$ClassExtends {$Properties($IsPropertyIncluded)[
$DocComments
    $name: $Type;]

    /** Initializes a new instance of the $Name class **/
    public constructor(init?: Partial<$Name>) {
        $ClassConstructor
    }
}]$Enums([TypeScriptModel])[// AutoGenerated File

$DocComments
export enum $Name {$Values[
$DocComments
    $Name = $Value][,]
}]$Interfaces([TypeScriptModel])[// AutoGenerated File

$FormulateInterfaceImports$DocComments
export interface $Name {$Properties[
$DocComments
    public $name: $Type;
]$Methods[
$DocComments
    $name($Parameters[$name: $Type][, ]): $Type;]
}]
